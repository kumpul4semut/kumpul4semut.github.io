{
  "version": 3,
  "sources": ["../../../src/optimizer/transforms/optionalize.ts"],
  "sourcesContent": ["import type {AlternativeElementNode} from '../../parser/parse.js';\nimport type {Visitor} from '../../traverser/traverse.js';\nimport {isAlternativeContainer, isQuantifiable} from '../../parser/node-utils.js';\nimport {createQuantifier} from '../../parser/parse.js';\nimport {isAllowedSimpleNode, isNodeEqual} from './extract-prefix.js';\n\n/**\nCombine adjacent alternatives with only an added last node as the difference.\n*/\nconst optionalize: Visitor = {\n  '*'({node}) {\n    if (!isAlternativeContainer(node) || node.body.length < 2) {\n      return;\n    }\n    const {body} = node;\n    const newAlts = [body[0]];\n    let lastAltKept = body[0];\n    for (let i = 1; i < body.length; i++) {\n      const alt = body[i];\n      const altKids = alt.body;\n      const prevAltKids = lastAltKept.body;\n      const lengthDiff = Math.abs(altKids.length - prevAltKids.length);\n      if (!lengthDiff) {\n        if (isNodeArrayEqual(altKids, prevAltKids)) {\n          // Don't keep this alt\n          continue;\n        }\n      } else if (lengthDiff === 1) {\n        const isPrevAltLonger = !!(prevAltKids.length > altKids.length);\n        let altKidsComp = altKids;\n        let prevAltKidsComp = prevAltKids;\n        isPrevAltLonger ? (prevAltKidsComp = prevAltKids.slice(0, -1)) : (altKidsComp = altKids.slice(0, -1));\n        if (isNodeArrayEqual(altKidsComp, prevAltKidsComp)) {\n          if (isPrevAltLonger) {\n            // If the prev alt has an extra node, put its last node in a greedy `?`\n            const prevAltLastKid = prevAltKids.at(-1);\n            if (prevAltLastKid && isDirectlyQuantifiable(prevAltLastKid)) {\n              prevAltKids.pop();\n              prevAltKids.push(createQuantifier('greedy', 0, 1, prevAltLastKid));\n              // Don't keep this alt\n              continue;\n            }\n          // Don't apply if the last alt was empty and there are more than two alts, since that\n          // would lengthen e.g. `(?:|a|b)` to `(?:a??|b)`, without enabling group unwrapping\n          } else if (prevAltKids.length > 0 || body.length === 2) {\n            // Since this alt has an extra node compared to prev, add the last node of this alt to\n            // the prev, but within a lazy `??`\n            const altLastKid = altKids.at(-1);\n            if (altLastKid && isDirectlyQuantifiable(altLastKid)) {\n              prevAltKids.push(createQuantifier('lazy', 0, 1, altLastKid));\n              // Don't keep this alt\n              continue;\n            }\n          }\n        }\n      }\n      newAlts.push(alt);\n      lastAltKept = alt;\n    }\n    node.body = newAlts;\n  },\n};\n\nfunction isDirectlyQuantifiable(node: AlternativeElementNode) {\n  // Avoid chaining `?` quantifiers since that can come out as `?{0,1}` and be longer than input\n  return isQuantifiable(node) && node.type !== 'Quantifier';\n}\n\n// Returns `false` if the arrays contain a node type it doesn't know how to compare\nfunction isNodeArrayEqual(a: Array<AlternativeElementNode>, b: Array<AlternativeElementNode>) {\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; i++) {\n    if (!isAllowedSimpleNode(a[i]) || !isAllowedSimpleNode(b[i])) {\n      return false;\n    }\n    if (!isNodeEqual(a[i], b[i])) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport {\n  optionalize,\n};\n"],
  "mappings": "aAEA,OAAQ,0BAAAA,EAAwB,kBAAAC,MAAqB,6BACrD,OAAQ,oBAAAC,MAAuB,wBAC/B,OAAQ,uBAAAC,EAAqB,eAAAC,MAAkB,sBAK/C,MAAMC,EAAuB,CAC3B,IAAI,CAAC,KAAAC,CAAI,EAAG,CACV,GAAI,CAACN,EAAuBM,CAAI,GAAKA,EAAK,KAAK,OAAS,EACtD,OAEF,KAAM,CAAC,KAAAC,CAAI,EAAID,EACTE,EAAU,CAACD,EAAK,CAAC,CAAC,EACxB,IAAIE,EAAcF,EAAK,CAAC,EACxB,QAASG,EAAI,EAAGA,EAAIH,EAAK,OAAQG,IAAK,CACpC,MAAMC,EAAMJ,EAAKG,CAAC,EACZE,EAAUD,EAAI,KACdE,EAAcJ,EAAY,KAC1BK,EAAa,KAAK,IAAIF,EAAQ,OAASC,EAAY,MAAM,EAC/D,GAAKC,GAKE,GAAIA,IAAe,EAAG,CAC3B,MAAMC,EAAqBF,EAAY,OAASD,EAAQ,OACxD,IAAII,EAAcJ,EACdK,EAAkBJ,EAEtB,GADAE,EAAmBE,EAAkBJ,EAAY,MAAM,EAAG,EAAE,EAAMG,EAAcJ,EAAQ,MAAM,EAAG,EAAE,EAC/FM,EAAiBF,EAAaC,CAAe,GAC/C,GAAIF,EAAiB,CAEnB,MAAMI,EAAiBN,EAAY,GAAG,EAAE,EACxC,GAAIM,GAAkBC,EAAuBD,CAAc,EAAG,CAC5DN,EAAY,IAAI,EAChBA,EAAY,KAAKX,EAAiB,SAAU,EAAG,EAAGiB,CAAc,CAAC,EAEjE,QACF,CAGF,SAAWN,EAAY,OAAS,GAAKN,EAAK,SAAW,EAAG,CAGtD,MAAMc,EAAaT,EAAQ,GAAG,EAAE,EAChC,GAAIS,GAAcD,EAAuBC,CAAU,EAAG,CACpDR,EAAY,KAAKX,EAAiB,OAAQ,EAAG,EAAGmB,CAAU,CAAC,EAE3D,QACF,CACF,EAEJ,UAhCMH,EAAiBN,EAASC,CAAW,EAEvC,SA+BJL,EAAQ,KAAKG,CAAG,EAChBF,EAAcE,CAChB,CACAL,EAAK,KAAOE,CACd,CACF,EAEA,SAASY,EAAuBd,EAA8B,CAE5D,OAAOL,EAAeK,CAAI,GAAKA,EAAK,OAAS,YAC/C,CAGA,SAASY,EAAiBI,EAAkCC,EAAkC,CAC5F,GAAID,EAAE,SAAWC,EAAE,OACjB,MAAO,GAET,QAASb,EAAI,EAAGA,EAAIY,EAAE,OAAQZ,IAI5B,GAHI,CAACP,EAAoBmB,EAAEZ,CAAC,CAAC,GAAK,CAACP,EAAoBoB,EAAEb,CAAC,CAAC,GAGvD,CAACN,EAAYkB,EAAEZ,CAAC,EAAGa,EAAEb,CAAC,CAAC,EACzB,MAAO,GAGX,MAAO,EACT,CAEA,OACEL,KAAA",
  "names": ["isAlternativeContainer", "isQuantifiable", "createQuantifier", "isAllowedSimpleNode", "isNodeEqual", "optionalize", "node", "body", "newAlts", "lastAltKept", "i", "alt", "altKids", "prevAltKids", "lengthDiff", "isPrevAltLonger", "altKidsComp", "prevAltKidsComp", "isNodeArrayEqual", "prevAltLastKid", "isDirectlyQuantifiable", "altLastKid", "a", "b"]
}
