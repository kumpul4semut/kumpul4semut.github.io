import type * as unifont from 'unifont';
import type { Storage } from 'unstorage';
import { DEFAULT_FALLBACKS } from './constants.js';
import type { FontFaceMetrics, generateFallbackFontFace } from './metrics.js';
import { type ResolveProviderOptions } from './providers/utils.js';
import type { FontFamily, FontType, ResolvedFontFamily } from './types.js';
export declare function toCSS(properties: Record<string, string | undefined>, indent?: number): string;
export declare function renderFontFace(properties: Record<string, string | undefined>): string;
export declare function generateFontFace(family: string, font: unifont.FontFaceData): string;
export declare function renderFontSrc(sources: Exclude<unifont.FontFaceData['src'][number], string>[]): string;
export declare function withoutQuotes(str: string): string;
export declare function extractFontType(str: string): FontType;
export declare function isFontType(str: string): str is FontType;
export declare function cache(storage: Storage, key: string, cb: () => Promise<Buffer>): Promise<Buffer>;
export interface ProxyURLOptions {
    /**
     * The original URL
     */
    value: string;
    /**
     * Specifies how the hash is computed. Can be based on the value,
     * a specific string for testing etc
     */
    hashString: (value: string) => string;
    /**
     * Use the hook to save the associated value and hash, and possibly
     * transform it (eg. apply a base)
     */
    collect: (data: {
        hash: string;
        type: FontType;
        value: string;
    }) => string;
}
/**
 * The fonts data we receive contains urls or file paths we do no control.
 * However, we will emit font files ourselves so we store the original value
 * and replace it with a url we control. For example with the value "https://foo.bar/file.woff2":
 * - font type is woff2
 * - hash will be "<hash>.woff2"
 * - `collect` will save the association of the original url and the new hash for later use
 * - the returned url will be `/_astro/fonts/<hash>.woff2`
 */
export declare function proxyURL({ value, hashString, collect }: ProxyURLOptions): string;
export declare function isGenericFontFamily(str: string): str is keyof typeof DEFAULT_FALLBACKS;
export type GetMetricsForFamilyFont = {
    hash: string;
    url: string;
};
export type GetMetricsForFamily = (name: string, 
/** A remote url or local filepath to a font file. Used if metrics can't be resolved purely from the family name */
font: GetMetricsForFamilyFont) => Promise<FontFaceMetrics>;
/**
 * Generates CSS for a given family fallbacks if possible.
 *
 * It works by trying to get metrics (using capsize) of the provided font family.
 * If some can be computed, they will be applied to the eligible fallbacks to match
 * the original font shape as close as possible.
 */
export declare function generateFallbacksCSS({ family, fallbacks: _fallbacks, font: fontData, metrics, }: {
    family: Pick<ResolvedFontFamily, 'name' | 'nameWithHash'>;
    /** The family fallbacks */
    fallbacks: Array<string>;
    font: GetMetricsForFamilyFont | null;
    metrics: {
        getMetricsForFamily: GetMetricsForFamily;
        generateFontFace: typeof generateFallbackFontFace;
    } | null;
}): Promise<null | {
    css: string;
    fallbacks: Array<string>;
}>;
/**
 * Resolves the font family provider. If none is provided, it will infer the provider as
 * one of the built-in providers and resolve it. The most important part is that if a
 * provider is not provided but `src` is, then it's inferred as the local provider.
 */
export declare function resolveFontFamily({ family, generateNameWithHash, root, resolveMod, }: Omit<ResolveProviderOptions, 'provider'> & {
    family: FontFamily;
    generateNameWithHash: (family: FontFamily) => string;
}): Promise<ResolvedFontFamily>;
export declare function sortObjectByKey<T extends Record<string, any>>(unordered: T): T;
/**
 * Extracts providers from families so they can be consumed by unifont.
 * It deduplicates them based on their config and provider name:
 * - If several families use the same provider (by value, not by reference), we only use one provider
 * - If one provider is used with different settings for 2 families, we make sure there are kept as 2 providers
 */
export declare function familiesToUnifontProviders({ families, hashString, }: {
    families: Array<ResolvedFontFamily>;
    hashString: (value: string) => string;
}): {
    families: Array<ResolvedFontFamily>;
    providers: Array<unifont.Provider>;
};
export declare function resolveEntrypoint(root: URL, entrypoint: string): URL;
